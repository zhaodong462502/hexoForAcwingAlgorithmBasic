[例题](https://www.acwing.com/problem/content/description/804/)

## 离散化适用场景

1. 将大范围（范围不确定）分散化的数据映射到一段***长度较小固定长度***的区间里。***让无序的数据能够有序存储***。这一点是使用离散化的***必要条件***。

   > 如果数据范围小，完全可以用数组直接存储。

2. 基于第一点，***实现有序存储后***，离散化可以较快的找到是否已存在该元素，类似HashMap。

例题关键内容

> 假定有一个无限长的数轴，数轴上每个坐标上的数都是 00。
>
> 现在，我们首先进行 n次操作，每次操作将某一位置 x上的数加 c。
>
> 接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r][�,�] 之间的所有数的和
>
> 

```c++
数据范围
−10^9≤x≤10^9,
1≤n,m≤10^5,
−10^9≤l≤r≤10^9,
−10000≤c≤10000
```

如例题，本题使用离散化的必要性是在于***x的数据范围太大***

x的数据范围（-10^9≤x≤10^9）太大，如果直接按x的值进行存储，开辟的数组空间太大。所以要用离散化映射到长度较小的区间。

> 如果x的范围很小，例如（-100<=x<=100）那么久不需要离散化,可以直接存储。
>
> a[x]+=c;



## 离散化过程中注意点

> 寻找位置采用了***二分查找***，二分查找的前提是***有序（一般为升序）无重复的序列***，否则查找位置就会出错。

### 寻找位置

```c++
int find(int x){
    int l=0,r= all.size()-1;
    while(l<r){
        int mid = l+r>>1;

       if(all[mid] < x) l=mid+1;
       else r=mid;

    }
    
    return r;
}
```



### 有序无重复处理

```c++
 //有序
 sort(all.begin(),all.end());
 //擦除重复
 all.erase(unique(all.begin(),all.end()),all.end());
    
```



## 离散化的解题步骤

> 读入输入到特殊处理集合，同时存入总集合（即用作长度固定较小序列）--> 总集合排序去重--> 将集合内元素插入以***总集合的长度***为范围的数组内，下标通过离散化获取 --> 输出查询结果
