- [ ] 区间问题和贪心章节的区间选点、区间最大不相交、区间分组、区间覆盖归纳总结

## sort函数

### 用法

Sort(start,end)

> 排序范围 [start,end)，左闭右开。

### struct 

和普通数组类似，排序0，n-1范围的元素，写成sort(range,range+n);

### Vector 

begin()函数，返回的是首元素的迭代器

end()函数，返回的是末尾元素的下一个位置的迭代器

排序vector，写成sort(vector.begin(),vector.end());



## c++操作符重载

```c++
struct Range{
	int l,r;
  const bool operator <(const Range &w) const{
    return l<w.l;
  } 
}range[N];

```

### 三个const的含义

#### 第一个const

返回值是const，不允许对该值直接赋值，此处小于号重载用不到，加号的重载可能用到

#### 第二个const

表示扩大入参范围，入参除了是Range 还可以是 const 修饰的Range

#### 第三个const

表示const 修饰的Range可以调用此方法



## 区间问题总结

### 问题类型

***区间合并***：多个区间合并成一个区间，求区间的个数。

***区间选点***：多个区间上选点，保证每个区间上至少有一个点，求点的最小数量。

***区间最大不相交***：多个区间选出一些区间，保证区间之间不相交，求可以选出的区间。

***区间分组***：多个区间能合并的分成一组，求分组的最小数量。

***区间覆盖***：给定一个目标区间，从多个区间中选出一些区间能够把目标区间完全覆盖，求选出区间的最小数量。



| 类型           | 相同点               | 不同点                                                       | 说明                                                         |
| -------------- | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 区间合并       | 左端点从小到大排序   | 下一组左端点大于最大右端点时，则需要单独判断，此处是区间数量加1，同时更新最大右端点 |                                                              |
| 区间选点       | 左端点从小到大排序   | 下一组左端点大于最小右端点时，则需要单独判断，此处是点数量加1，同时更新最大右端点 | 相交部分用最小右端点判断                                     |
| 区间最大不相交 | 左端点从小到大排序   | 下一组左端点大于最小右端点时，则需要单独判断，此处是区间数量加1，同时更新最大右端点 | 和区间选点一致                                               |
| 区间分组       | 左端点从小到大排序   | 下一组左端点大于已合并的区间里的***最小右端点***时，则需要单独判断，此处是当前区间加入到最小堆中 | 最小右端点需要用***最小堆***处理，最后最小堆的大小即为分组数量。 |
| ***区间分组*** | ***离散化方式处理*** | 将每个区间首位简单离散化，左端点偶数，右端点奇数：b[idx++]= st*2；b[idx++]=ed\*2+1；循环b数组，遇到偶数加1，遇到奇数减1，最终剩余数量就是分组的最小数量。 |                                                              |
| 区间覆盖       | 左端点从小到大排序   | 从剩余区间里选出一组的左端点能够覆盖前面的右端点的的***最大右端点***的区间，选出后同时更新前面右端点的值 | 思路简单，代码实现有点技巧性。                               |

### 关键代码

#### 区间合并

```c++
int cnt =0,maxEd = -2e9;
for(int i=0;i<n;i++){
  //区间不相交情况处理
	if(range[i].l>maxEd){
    cnt++;
    maxEd = range[i].r;
  }else{
    //区间相交情况处理
    maxEd =max(maxEd,range[i].r);
  }
}
```



#### 区间选点/区间最大不相交

```c++
int cnt =0,minEd = 2e9;
for(int i=0;i<n;i++){
	//区间不相交情况处理
	if(range[i].l>minEd){
		cnt++;
	}else{
    //区间相交情况处理
		minEd = min(minEd,range[i].r);
	}
}
```

#### 区间分组

##### 常规解法

```c++
priority_queue<int ,vector<int>,greater<int >> heap;
for(int i=0;i<n;i++){
  //最小堆存的都是右端点，堆顶是最小右端点
  if(heap.empty() || range[i].l<=heap.top()){
    heap.push(range[i].r);
  }else{
    heap.pop();
    heap.push(range[i].r);
  }
}	

cout << heap.size()<<endl;
```

##### 离散化解法

```c++
while(n--){
  b[idx++] = l*2;
  b[idx++]=r*2+1;
}

int res =1,t=0;
for(int i=0;i<idx;i++){
  if(b[i] %2==0) t++;
  else t--;
  res = max(res,t);
}

cout << res<<endl;
```



#### 区间覆盖

```c++
int st,ed;
cin >>st>>ed;//st为目标区间的左端点,ed为目标区间的右端点

int cnt=0;
bool succ=false;//是否完全覆盖标志，有可能循环结束了区间也没有覆盖的情况
for(int i0;i<n;i++){
  int j=i,maxEd = -2e9;
  
  //从剩余区间中选出能够覆盖st的右端点最大的区间
  while(j<n && range[j].l>=st){
    maxEd = max(maxEd,range[j].r);
    j++;
  }
  //是否无法覆盖
  if(maxEd < st){
    break;
  }
  //计数加1
  cnt ++;
  //是否已经覆盖
  if(maxEd >= ed){
    succ = true;
    break;
  }
  
 	//没有覆盖则继续处理
  i=j-1;//while循环中j多加了一次这里需要减1
  st=maxEd;//下一个区间需要覆盖的左端点
  
}

if(succ) cout<< cnt<< endl;
else cout <<"-1"<<endl;
```

