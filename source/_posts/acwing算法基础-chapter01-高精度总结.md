## 高精度算法分类

分类：加、减、乘、除

> 其中加减乘都适用于两个数都是高精度，除法因为除数是高精度的话不好用整除的方法，所以除法时被除数是高精度，除数是整型。



## 高精度加减乘除的异同点

### 加和乘

#### 相同点

1. 需要***从低位到高位处理***

   ```c++
   for(int i=stra.size()-1;i>=0;i--) c.push_back(stra[i]-'0');
   ```

   

2. 加和乘***处理向上进位***

   ```c++
   int t=0;
   for(...){
   	t += a[i];
   	c.push_back(t % 10);
   	t /= 10;
   }
   ```

3. 可以使用***通用模板***

   > 加法

   ```c++
   c[i]+=a[i];
   c[i]+=b[i];
   //然后统一对c进行进位处理
   ```

   

   > 乘法

   ```c++
   c[i+j] = a[i]*b[j];
   //然后统一对c进行进位处理
   ```

## 减和除

### 相同点

1. 有可能当前位的数不够，需要***借用上一位***



### 不同点

1. 减法需要从低位到高位处理，除法是从高位到低位处理

2. 减法每一位都要处理上一位的***借位***情况，借位要么是0要么是1

   ```c++
   int t=0;
   //注意：a是从低位到高位排序
   for(int i=0;i<a.size();i++){
   	t = a[i]-t;
   	if(i<b.size()) t -= b[i];
   	c.push_back(t % 10);
   	
   	//下一位的借位
   	if(t <0) t=1;
   	else t = 0;
   	
   }
   ```

   

3. 除法更多的应该是叫***凑位***，把高位的数*10和低位的数合并，每个位置不需要再单独加减

   ```c++
   int r=0; //余数
   //注意a是从高位到低位排序
   for(int i=0;i<a.size();i++){
     r = r * 10+a[i];
     c.push_back(r /b);
    	r = r % b;
   }
   ```

   

4.除法处理前导0的情况需要翻转，把高位翻转到末尾

```c++
reverse(c.begin(),c.end());
```





### 处理前导0的方式

四种运算都一样，只是除法先要翻转数组

```c++
while(c.size()>1 && c.back()==0) c.pop_back();
```

